---
title: "Advent of Code 2022"
output: 
    github_document: 
        toc: true
        toc_depth: 1
---

```{r setup}
knitr::opts_chunk$set(echo = TRUE)
purrr::walk(list.files(here::here("R"), full.names = TRUE), source)
library(dplyr)
library(readr)
library(purrr)
```

Here's my work on Advent of Code 2022.

# Day 1

## Part 1

```{r day01-part1}
d01_input <- tibble(calories = readLines(here::here("input/day_01.txt"))) |> 
  mutate(elf = cumsum(calories == "") + 1) |> 
  filter(calories != "") |> 
  mutate(across(calories, as.integer)) |> 
  group_by(elf) |> 
  summarise(across(calories, sum))

d01_input |> 
  slice_max(calories, n = 1)
```

## Part 2

```{r day01-part2}
d01_input |> 
  slice_max(calories, n = 3) |> 
  summarise(across(calories, sum))
```

# Day 2

## Part 1

```{r day02-part1}
d02_input <- read_delim(
  here::here("input/day_02.txt"),
  delim = " ",
  col_names = c("opp", "me"), 
  show_col_types = FALSE
)
d02_input |> 
  mutate(
    opp_int = map_int(opp, ~ switch(.x, A = 1L, B = 2L, C = 3L)), 
    me_int = map_int(me, ~ switch(.x, X = 1L, Y = 2L, Z = 3L))
  ) |> 
  mutate(diff = (me_int - opp_int) %% 3) |> 
  # 2 = loss
  # 0 = draw
  # 1 = win
  mutate(score = c(3, 6, 0)[diff + 1L]) |> 
  summarise(total_score = sum(me_int + score))
```

## Part 2

```{r day02-part2}
d02_input |> 
  mutate(
    opp_int = map_int(opp, ~ switch(.x, A = 1L, B = 2L, C = 3L)), 
    diff = map_int(me, ~ switch(.x, X = 2L, Y = 0L, Z = 1L))
  ) |> 
    mutate(
      # Is this the most elegant modular arithmetic? Almost certainly not. Is
      # there a simpler way to do this arithmetic that avoids quite so many
      # operations? Almost certainly yes.
      me_int = ((((opp_int + 1L) %% 3) + ((diff + 1L) %% 3)) %% 3) + 1L, 
      score = c(3, 6, 0)[diff + 1L]
    ) |> 
  summarise(total_score = sum(me_int + score))
```

